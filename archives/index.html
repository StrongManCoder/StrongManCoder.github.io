<!DOCTYPE html>

<html lang="zh-Hans">

<head>
  
  <title>Archive - 70Qiang</title>
  <meta charset="UTF-8">
  <meta name="description" content="随心 随笔 随想">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="随心 随笔 随想">
<meta property="og:type" content="website">
<meta property="og:title" content="70Qiang">
<meta property="og:url" content="http://yoursite.com/archives/index.html">
<meta property="og:site_name" content="70Qiang">
<meta property="og:description" content="随心 随笔 随想">
<meta property="og:locale">
<meta property="article:author" content="70Qiang">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css?v=233" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1616568501316">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="70Qiang" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="70Qiang"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="70Qiang">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="70Qiang" alt="70Qiang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>7</div>
        <div><span>Tags</span>14</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/BAT/" style="font-size: 10px;">BAT</a> <a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/KVC/" style="font-size: 10px;">KVC</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS%E6%B5%8B%E8%AF%95%E5%8C%85/" style="font-size: 10px;">iOS测试包</a> <a href="/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9D%83%E9%99%90/" style="font-size: 10px;">文件夹权限</a> <a href="/tags/%E7%9B%91%E5%90%AC/" style="font-size: 10px;">监听</a> <a href="/tags/%E9%9B%86%E9%94%A6/" style="font-size: 10px;">集锦</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 70Qiang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2016/09/13/KVO%E5%B0%8F%E8%AE%B0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="KVO小记" class="lazyload">
                    <h1>KVO小记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年09月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <h1 id="KVO浅析"><a href="#KVO浅析" class="headerlink" title="KVO浅析"></a>KVO浅析</h1><h3 id="KVO-Key-Value-Observing-键值监听"><a href="#KVO-Key-Value-Observing-键值监听" class="headerlink" title="KVO Key-Value Observing 键值监听"></a>KVO Key-Value Observing 键值监听</h3><p>KVO是一个观察者模式。观察一个对象的属性，注册一个指定的路径，若这个对象的的属性修改，则KVO会自动通知观察者。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-注册监听"><a href="#1-注册监听" class="headerlink" title="1.注册监听"></a>1.注册监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     *  注册一个监听</span><br><span class="line">     *</span><br><span class="line">     *  @param observer 观察者</span><br><span class="line">     *  @param keyPath  属性名字</span><br><span class="line">     *  @param options  属性的变化</span><br><span class="line">     *  @param context  void类型</span><br><span class="line">     */</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> *  当监控的某个属性的值改变了就会调用</span><br><span class="line"> *</span><br><span class="line"> *  @param keyPath 属性名（哪个属性改了？）</span><br><span class="line"> *  @param object  哪个对象的属性被改了？</span><br><span class="line"> *  @param change  属性的修改情况（属性原来的值、属性最新的值）</span><br><span class="line"> *  @param context void类型</span><br><span class="line"> */</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@对象的%@属性改变了：%@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-移除观察-释放内存，在dealloc函数释放"><a href="#3-移除观察-释放内存，在dealloc函数释放" class="headerlink" title="3.移除观察,释放内存，在dealloc函数释放"></a>3.移除观察,释放内存，在dealloc函数释放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> *  移除观察者</span><br><span class="line"> *</span><br><span class="line"> *  @param observer 观察者</span><br><span class="line"> *  @param keyPath  观察的属性</span><br><span class="line"> */</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0);</span><br></pre></td></tr></table></figure>
<p>KVO的观察者是由两种模式的。一种是自动通知，一种是手动通知。<br><strong>自动通知</strong>自动监听对象的属性，不管这个属性的前后属性变化的值是否一样，都会通知观察者。<br>手动通知重写willChangeValueForKey:和didChangeValueForKey: 方法通知观察者。<br>一般都是用自动通知，方便快捷。<br>下面两种写法，都会举例说明。</p>
<h3 id="自动通知-主要看监听回调的分析"><a href="#自动通知-主要看监听回调的分析" class="headerlink" title="自动通知,主要看监听回调的分析"></a>自动通知,主要看监听回调的分析</h3><p>场景：模拟人年龄的变化，看接受通知的次数</p>
<figure class="highlight plain"><figcaption><span>(void)viewDidLoad &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.person = [[Person alloc]init];</span><br><span class="line">    self.person.age = 15;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  注册监听</span><br><span class="line">     */</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    /**</span><br><span class="line">     *  第二次赋值 20</span><br><span class="line">     */</span><br><span class="line">    self.person.age = 20;</span><br><span class="line">    /**</span><br><span class="line">     *  再次赋值 20</span><br><span class="line">     */</span><br><span class="line">    self.person.age = 20;</span><br><span class="line">    /**</span><br><span class="line">     *  详细见控制台输出,只比较新旧值</span><br><span class="line">     */    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  监听回调</span><br><span class="line"> */</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;\n change = %@ \n keyPath =%@ object =%@ context=%@&quot;,change ,keyPath,object,context);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /** ============================ 控制台输出 ===================================</span><br><span class="line">     * </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     change = &#123;</span><br><span class="line">     kind = 1;</span><br><span class="line">     new = 20;        ---------&gt;新的值是 20 注册监听后，observeValueForKeyPath会回调输出</span><br><span class="line">     old = 15;        ---------&gt;旧的值是 15 注册监听前，这个属性初始化时候就是15。</span><br><span class="line">     &#125;</span><br><span class="line">     keyPath =age object =&lt;Person: 0x7feec962a9d0&gt; context=(null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     change = &#123;</span><br><span class="line">     kind = 1;</span><br><span class="line">     new = 20;        ---------&gt;新的值是 20 再次传入20，observeValueForKeyPath这个还是会回调输出</span><br><span class="line">     old = 20;        ---------&gt;旧的值是 20</span><br><span class="line">     &#125;</span><br><span class="line">     keyPath =age object =&lt;Person: 0x7feec962a9d0&gt; context=(null)</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  由控制台输出结果得出结论，只要是对属性进行改变，不管属性的值是否变化，不区分新旧值的变化，observeValueForKeyPath都是回调，通知观察者的。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  移除观察</span><br><span class="line">     */</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h3><p>场景：模拟人年龄的变化，看接受通知的次数<br>需要在Person类里面重写方法，具体看实现代码</p>
<figure class="highlight plain"><figcaption><span>(void)viewDidLoad &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.person = [[Person alloc]init];</span><br><span class="line">    self.person.age = 15;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  注册监听</span><br><span class="line">     */</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    /**</span><br><span class="line">     *  第二次赋值 20</span><br><span class="line">     */</span><br><span class="line">    self.person.age = 20;</span><br><span class="line">    /**</span><br><span class="line">     *  再次赋值 20</span><br><span class="line">     */</span><br><span class="line">    self.person.age = 20;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  详细见控制台输出,只比较新旧值</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  监听回调</span><br><span class="line"> */</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;\n change = %@ \n keyPath =%@ object =%@ context=%@&quot;,change ,keyPath,object,context);</span><br><span class="line"></span><br><span class="line">    /** ============================ 控制台输出 ===================================</span><br><span class="line">     * </span><br><span class="line">     change = &#123;</span><br><span class="line">     kind = 1;</span><br><span class="line">     new = 20;        ---------&gt;新的值是 20 注册监听后，observeValueForKeyPath会回调输出</span><br><span class="line">     old = 15;        ---------&gt;旧的值是 15 注册监听前，这个属性初始化时候就是15。</span><br><span class="line">     &#125;</span><br><span class="line">     keyPath =age object =&lt;Person: 0x7feec962a9d0&gt; context=(null)</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">   /**</span><br><span class="line">     *  和自动通知输出作对比，这样明白理解。主要是在Person类里面重写了 automaticallyNotifiesObserversForKey 这个方法。以及重写age的setter方法</span><br><span class="line">     *  由控制台输出结果得出结论，只要监听对象的属性值前后发生改变，observeValueForKeyPath就回调，通知观察者的。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  移除观察</span><br><span class="line">     */</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Person类的实现"><a href="#Person类的实现" class="headerlink" title="Person类的实现"></a>Person类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//  Person.m</span><br><span class="line">//  KVO</span><br><span class="line">//</span><br><span class="line">//  Created by XXXXXX on 15/11/9.</span><br><span class="line">//  Copyright © 2015年 Simon. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">-(void)setAge:(float)age&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  判断两值是否一样，一样就不复赋值了</span><br><span class="line">     */</span><br><span class="line">    if (_age!= age) &#123;</span><br><span class="line">        [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">        _age = age;</span><br><span class="line"></span><br><span class="line">        [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  是否对这个key开启自动发送通知</span><br><span class="line"> *</span><br><span class="line"> *  @param theKey 监听的属性key</span><br><span class="line"> *</span><br><span class="line"> *  @return 布尔值</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</span><br><span class="line">    BOOL automatic = NO;</span><br><span class="line"></span><br><span class="line">    if ([theKey isEqualToString:@&quot;age&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        automatic = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        automatic=[super automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>观察了自动通知和手动通知，各有所长，看你们喜欢哪个。记住手动通知必须重写方法，只有新旧值前后不一样才会通知。自动通知就不管新旧值是否一样，都说告诉观察者。</strong><br>实现原理可以参考这个博客，写的很详细.<br><a href="http://blog.csdn.net/kesalin/article/details/8194240" target="_blank" rel="noopener">[深入浅出Cocoa]详解键值观察（KVO）及其实现机理</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/06/23/BAT%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E8%AF%95%E7%AD%94%E7%99%BE%E5%BA%A6%E4%BA%8C%E9%9D%A2/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="BAT面试指南试答百度" class="lazyload">
                    <h1>BAT面试指南试答百度</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年06月23日</a>
            <a><i class="nexmoefont icon-areachart"></i>3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 13 分钟</a>
        </div>

        <article>
            
                <h2 id="1-1-说说OC中load方法和initialize方法的异同。"><a href="#1-1-说说OC中load方法和initialize方法的异同。" class="headerlink" title="1.1 说说OC中load方法和initialize方法的异同。"></a>1.1 说说OC中load方法和initialize方法的异同。</h2><p>对于load方法，官方的文档说明如下：</p>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
<p>The order of initialization is as follows: <em> All initializers in any framework you link to. </em> All +load methods in your image. <em> All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image. </em> All initializers in frameworks that link to you.</p>
<p>In addition: <em> A class’s +load method is called after all of its superclasses’ +load methods. </em> A category +load method is called after the class’s own +load method.</p>
<p>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>
<p><em>文档也说清楚了，对于load方法，只要文件被引用就会被调用。load方法调用顺序是父类的load方法优先调用于子类的load方法，而本类的load方法优</em></p>
<p>对于+initialize方法，官方的文档说明如下：</p>
<p>Initializes the class before it receives its first message.</p>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
<figure class="highlight plain"><figcaption><span>(void)initialize &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, it’s important to do the minimum amount of work necessary in initialize methods.</p>
<p>Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks.</p>
<p>Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization. initialize is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load methods.</p>
<p><em>文档也很明确的说明了：文件被引用并不代表initialize就会被调用，只有类或者子类中第一次有函数调用时，都会调用initialize。initialize是线程安全的，我们不能在initialize方法中加锁，这有可能导致死锁。我们也不应该在函数中实现复杂的代码。initialize只会被调用一次。</em></p>
<p>+load和+initialize共同点：</p>
<p>在不考虑开发者主动使用的情况下，系统最多会调用一次<br>如果父类和子类都被调用，父类的调用一定在子类之前<br>这两个方法不适合做复杂的操作，应该是足够简单<br>在使用时都不要过重地依赖于这两个方法，除非真正必要。在使用时一定要注意防止死锁！<br>都不需要调用[super load]、[super initialize]<br>+load和+initialize不同点：</p>
<p>load方法没有自动释放池，如果做数据处理，需要释放内存，则开发者得自己添加autoreleasepool来管理内存的释放。<br>和load不同，即使子类不实现initialize方法，也会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。</p>
<h2 id="1-2-说说你对block的理解。"><a href="#1-2-说说你对block的理解。" class="headerlink" title="1.2 说说你对block的理解。"></a>1.2 说说你对block的理解。</h2><p>题目问得太简单太宽泛了，作为求职者，不防反问面试官想听听哪些方面的。比如，我们可以反问是想问有哪些block类型？还是block的应用或是block循环引用问题及解决方案？</p>
<p>对于block类型有哪些，看看唐巧的技术博客中的一篇谈Objective-C block的实现，里面讲到Block分为三种，分别是全局block、栈block和堆block。ARC之后，我们并不需要手动copy到堆上，通常都已经交给编译器来完成了。</p>
<p>如果是想问block循环引用的问题及解决方案，大家可以阅读笔者之前所写的一篇如何分析循环引用及如何解决iOS Block循环引用精讲</p>
<p>如果是想问block的应用，那么应用场景就太多了。比如GCD+block就非常多，而我的项目中除了老代码没有修改成block版本，新的代码都是能block来实现的。</p>
<h2 id="1-3-说说你对runtime的理解"><a href="#1-3-说说你对runtime的理解" class="headerlink" title="1.3 说说你对runtime的理解"></a>1.3 说说你对runtime的理解</h2><p>这个问题与第三个问题一样，都过于宽泛了。还是反问面试官以确定面试官想知道什么吧。</p>
<p>1、消息是如何转发的？</p>
<p>这里有一篇文章讲的就是Runtime Message Forwarding，我认为只有讲讲消息转发的流程就可以了。动态解析过程大致是这样的：通过resolveInstanceMethod允许开发者决定是否动态添加方法，若返回NO，就直接进入doesNotRecognizeSelector，流程结束，否则需要通过class_addMethod动态添加方法并返回YES并进入下一步。forwardingTargetForSelector是第二步，允许开发者决定将由哪个对象响应这个selector，如果返回nil，则直接进入doesNotRecognizeSelector，流程结束，否则需要返回一个对象，但不能是self。进入第三步指定方法签名methodSignatureForSelector，若返回nil，则直接进入doesNotRecognizeSelector且流程结束，否则指定签名，并进入下一步forwardInvocation。forwardInvocation允许开发者修改响应者、方法实现等。若没有实现forwardInvocation，则直接进入doesNotRecognizeSelector，流程结束。</p>
<h2 id="2、方法调用会被缓存吗？如何缓存过，又是如何查找的呢？"><a href="#2、方法调用会被缓存吗？如何缓存过，又是如何查找的呢？" class="headerlink" title="2、方法调用会被缓存吗？如何缓存过，又是如何查找的呢？"></a>2、方法调用会被缓存吗？如何缓存过，又是如何查找的呢？</h2><p>方法是会缓存进来了，不然下次再调用又要重新查一次，效率是不高的。采用散列（哈希）的方式来缓存，查询的效率是比较高的，因此内部会采用散列缓存起来。</p>
<h2 id="3、对象的内存是如何布局的？"><a href="#3、对象的内存是如何布局的？" class="headerlink" title="3、对象的内存是如何布局的？"></a>3、对象的内存是如何布局的？</h2><p>成员变量（包括父类）都保存在对象本身的存储空间内；本类的实例方法保存在类对象中，本类的类方法保存在元类对象中；父类的实例方法保存在各级super class中，父类的类方法保存在各级super meta class中。</p>
<p>不知道这个答案是否合适！</p>
<h2 id="4、runtime有哪些应用场景？"><a href="#4、runtime有哪些应用场景？" class="headerlink" title="4、runtime有哪些应用场景？"></a>4、runtime有哪些应用场景？</h2><p>关于runtime的应用是很广泛的，日常开发中所用过的场景：</p>
<p>给category添加属性<br>Method-Swizzling hook方法，然后交换方法实现来达到调用系统方法之前先做一些额外的处理<br>埋点处理<br>字典与模型互转<br>模型自动获取所有属性并转换成SQL语句操作数据库<br>想到的也就这么些，大家可以补充！</p>
<h2 id="1-4-说说你对MVC和MVVM的理解。"><a href="#1-4-说说你对MVC和MVVM的理解。" class="headerlink" title="1.4 说说你对MVC和MVVM的理解。"></a>1.4 说说你对MVC和MVVM的理解。</h2><p>MVC是出现比较早的架构设计模式，而且到现在已经是很成熟了。出现MVVM的原因是MVC中的V越来越复杂，于是才有人想要给V瘦身。</p>
<p>本人在公司的项目中并没有使用过MVVM架构设计模式，一直都是使用MVC的。但是项目比较大，有多个团队同时迭代。我也看了看别的团队的人写的代码，发现他们在网上看过MVVM，于是在项目中纷纷采用MVVM的思想，一个页面分为头、中、尾三个部分，结果他们把这三个部分建立成三个view类，然后写了一堆的delegate回调到V。当我看到这些代码的时候，我还是庆幸的，他们不是我团队的人，代码也不需要我们来维护。</p>
<p>我并不否定MVVM，但是MVVM若配上RAC后，对于代码review没有做好的项目，那是可以害死很多人的，特别是新手接过来之后，什么都不懂，也不会修改他人的代码。我所接触到过的MVVM项目，都是别人的项目，看到很多项目的源代码，包括帮别人改bug的时候，发现调用层次太深，查问题也困难了很多。</p>
<p>其实，采用MVC的项目中，我发现很多人并不充分利用M的作用。我看过很多项目的源代码，M只是添加个属性，并没有做数据处理，而是放在V中处理的。笔者对于可以放在M中处理的数据，是不会交给V做的。比如接口返回来的字段是标识状态的，但是最终要根据状态展示对应的文案，则笔者会增加辅助字段处理，交给M处理。</p>
<p>因此，我个人认为不管是MVC还是MVVM，都有其优缺点，不要过分依赖，也不要理所当然，而应该明确自己的团队是什么样类型的团队。如果都是高级开发者，采用哪种都没有什么问题的；如果基本是初中级，别整什么MVVM了，还是使用传统的MVC吧，谁都可以读懂！</p>
<h2 id="1-5-说说UITableView的调优"><a href="#1-5-说说UITableView的调优" class="headerlink" title="1.5 说说UITableView的调优"></a>1.5 说说UITableView的调优</h2><p>通常来说，在开发中注意以下问题，可以使列表滚动比较流畅，但是对于特别复杂的列表就需要做额外的优化处理：</p>
<p>重用cell，设置好cellIdentifier<br>重用header、footer view，设置好identifier<br>若高度固定，直接使用rowHight；若不固定则使用heightForRowAtIndexPath代理方法<br>缓存cell的高度、header/footer view的高度<br>不要修改view的opaque，默认就是YES,表示不透明度<br>不要动态添加子view到cell上，直接在初始时创建，然后做显示与隐藏操作<br>尽量不要直接使用cornerRadius，采用镂空图或者Core Graphics API来绘制<br>将I/O操作、复杂运算放到子线程中处理，再回到主线程更新UI<br>如果列表比较复杂，对于上面的做好后，还是不够流畅，就需要通过Instruments工具来检测哪些地方可以优化了。笔者开源过一个自动计算行高的库，对于一般的app，其性能是可以了：开源HYBMasonryAutoCellHeight自动计算行高，带有高度缓存，对于不同状态下也是会缓存的。</p>
<h2 id="1-6-谈谈你对ARC的理解。"><a href="#1-6-谈谈你对ARC的理解。" class="headerlink" title="1.6 谈谈你对ARC的理解。"></a>1.6 谈谈你对ARC的理解。</h2><p>ARC是编译器帮我们完成的，我们不再手动添加retain、relase、autorelease，而且在运行期还会帮助我们优化。但是ARC并不是万能的，它并不能自我理解循环引用问题，依然需要我们手动解决循环引用的问题。</p>
<p>ARC管理都会放到自动释放池中，如果我们需要做一些循环操作，生成大量的临时变量，我们还是需要加一下autoreleasepool，以及时地释放内存。</p>
<p>ARC下对于属性修饰符不同，其内存管理策略也不一样：</p>
<p>strong：强引用，引用计数加1<br>weak：弱引用，引用计数没有加1<br>copy：强引用，引用计数加1<br>ARC下还是有可能出现内存泄露的，内存得不到释放，特别是使用block的时候，一定要学会分析是否形成循环引用。看看如何分析循环引用iOS Block循环引用精讲。</p>
<h2 id="2-1-野指针是什么，iOS开发中什么情况下会有野指针？"><a href="#2-1-野指针是什么，iOS开发中什么情况下会有野指针？" class="headerlink" title="2.1 野指针是什么，iOS开发中什么情况下会有野指针？"></a>2.1 野指针是什么，iOS开发中什么情况下会有野指针？</h2><p>所谓野指针，是指指向内存已经被释放的内存区的指针。</p>
<p>在iOS开发中，在iOS7下遇到一个bug：当进入播放页面时马上又返回上一个页面，偶尔出现闪退，原因就是出现了野指针（访问了已释放的对象内存区）。当进入播放页面时，就会立刻去解析视频数据，内部是FFMPEG操作，当快速返回上一个页面时，FFMPEG还在操作中，导致访问了已释放的对象。内存这个问题是SDK内部的问题，我们也不能解决，只能抛给SDK提供者来解决。</p>
<p>还有就是在使用block时，不小心也会出现野指针。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/06/22/%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84-iOS/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="招聘一个靠谱的 iOS" class="lazyload">
                    <h1>招聘一个靠谱的 iOS</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年06月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 10 分钟</a>
        </div>

        <article>
            
                <h2 id="一个靠谱的简历"><a href="#一个靠谱的简历" class="headerlink" title="一个靠谱的简历"></a>一个靠谱的简历</h2><p>简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 iOS 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：</p>
<figure class="highlight plain"><figcaption><span>-> IPHONE IPhone</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Xcode -&gt; XCode xcode</span><br><span class="line">Objective-C -&gt; Object-C</span><br><span class="line">JSON -&gt; Json</span><br><span class="line">HTTP -&gt; Http</span><br></pre></td></tr></table></figure>
<p>还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。<br>面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。</p>
<h2 id="关于算法"><a href="#关于算法" class="headerlink" title="关于算法"></a>关于算法</h2><p>我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。</p>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>这是一个重点考察项，曾经在微博上发过一个风格纠错题：<br><img src="http://7xvlgm.com2.z0.glb.qiniucdn.com/16-6-22/97051734.jpg" alt></p>
<p>也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀</p>
<h2 id="一个区分度很大的面试题"><a href="#一个区分度很大的面试题" class="headerlink" title="一个区分度很大的面试题"></a>一个区分度很大的面试题</h2><p>考察一个面试者基础咋样，基本上问一个 @property 就够了：</p>
<ul>
<li>@property 后面可以有哪些修饰符？</li>
<li>什么情况使用 weak 关键字，相比 assign 有什么不同？</li>
<li>怎么用 copy 关键字？</li>
<li>这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></li>
<li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</li>
</ul>
<p>这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：</p>
<ul>
<li>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</li>
<li>@protocol 和 category 中如何使用 @property</li>
<li>runtime 如何实现 weak 属性</li>
</ul>
<p>每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。</p>
<h2 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h2><p>总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：</p>
<p>[※]@property中有哪些属性关键字？<br>[※]weak属性需要在dealloc中置nil么？<br>[※※]@synthesize和@dynamic分别有什么作用？<br>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？<br>[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？<br>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？<br>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</p>
<p>[※※]objc中向一个nil对象发送消息将会发生什么？<br>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？<br>[※※※]什么时候会报unrecognized selector的异常？<br>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）<br>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？<br>[※※※※]下面的代码输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）<br>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？<br>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？<br>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？<br>[※※※※※]runtime如何实现weak变量的自动置nil？<br>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p>
<p>[※※※]runloop和线程有什么关系？<br>[※※※]runloop的mode作用是什么？<br>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？<br>[※※※※※]猜想runloop内部是如何实现的？</p>
<p>[※]objc使用什么机制管理对象内存？<br>[※※※※]ARC通过什么方式帮助开发者管理内存？<br>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）<br>[※※※※]BAD_ACCESS在什么情况下出现？<br>[※※※※※]苹果是如何实现autoreleasepool的？</p>
<p>[※※]使用block时什么情况会发生引用循环，如何解决？<br>[※※]在block内如何修改block外部变量？<br>[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</p>
<p>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？<br>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）<br>[※※※※]dispatch_barrier_async的作用是什么？<br>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？<br>[※※※※※]以下代码运行结果如何？</p>
<figure class="highlight plain"><figcaption><span>(void)viewDidLoad</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[※※]<code>addObserver:forKeyPath:options:context:</code>各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？<br>[※※※]如何手动触发一个value的KVO<br>[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？<br>[※※※※]KVC的keyPath中的集合运算符如何使用？<br>[※※※※]KVC和KVO的keyPath一定是属性么？<br>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？<br>[※※※※※]apple用什么方式实现对一个对象的KVO？</p>
<p>[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?<br>[※※※※※]IB中User Defined Runtime Attributes如何使用？</p>
<p>[※※※]如何调试BAD_ACCESS错误<br>[※※※]lldb（gdb）常用的调试命令？</p>
<p>这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。</p>
<h2 id="业务能力"><a href="#业务能力" class="headerlink" title="业务能力"></a>业务能力</h2><p>毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。<br>要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~</p>
<p>程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？<br>架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。</p>
<p>网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。</p>
<h2 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h2><p>大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。</p>
<h2 id="转载原地址：http-blog-sunnyxx-com"><a href="#转载原地址：http-blog-sunnyxx-com" class="headerlink" title="转载原地址：http://blog.sunnyxx.com"></a>转载原地址：<a href="http://blog.sunnyxx.com" target="_blank" rel="noopener">http://blog.sunnyxx.com</a></h2>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/06/22/Mac-%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9D%83%E9%99%90/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="Mac 下修改文件夹权限" class="lazyload">
                    <h1>Mac 下修改文件夹权限</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年06月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>133 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>#Mac 下修改文件夹权限</p>
<p>之所以写这个是因为之前使用sudo权限创建的Hexo的文件夹,导致new的MD文件在使用MWeb Lite的时候导致权限问题不能保存,后来发现Mac一个简单的方法批量处理文件和文件夹权限,如下图所示<br><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-22/67054971.jpg" alt><br>然后就可以爽快的使用啦 ,这个方法比使用命令行是不是更人性化一点(笑).<br>图片失效了 ಥ_ಥ哭(看我我要重新整理图床了)</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/06/22/iOS%E6%B5%8B%E8%AF%95%E5%8C%85%E8%87%AA%E5%8A%A8%E5%88%86%E5%8F%91%EF%BC%8C%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%EF%BC%8C%E6%95%88%E7%8E%87%E6%8F%90%E9%AB%98%E7%99%BE%E5%88%86%E7%99%BE/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="iOS测试包自动分发，一键安装，效率提高百分百" class="lazyload">
                    <h1>iOS测试包自动分发，一键安装，效率提高百分百</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年06月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>957 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <p>一个可以让你快速、方便、一次配置，终生受益的测试包分发教程。你还在傻傻的用airdrop,qq么？</p>
<p>#使用环境：</p>
<p>适合iOS开发者，常需要发布测试包给各类人员，那么以后再也无需多余操作，一键搞定。公司有内网服务器，或用Mac os的同学都可以使用。非越狱手机可以使用，只要正常绑定过证书就没有问题。</p>
<p>以下是教程，相当简单。<br>服务器ip以192.168.1.188为例，端口8080</p>
<p>#第一步，配置run script打包ipa并完成ipa上传</p>
<p>部署过程，Xcode中打开target-&gt;build phases-&gt;add build phase-&gt;add run script如图添加如下代码，并根据自己使用环境做一下调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># shell script goes here</span><br><span class="line"></span><br><span class="line"># compress application.</span><br><span class="line">if [ &quot;$&#123;CONFIGURATION&#125;&quot; = &quot;ad_hoc&quot; ]; then #判断发布版本</span><br><span class="line"></span><br><span class="line">/bin/mkdir $CONFIGURATION_BUILD_DIR/Payload</span><br><span class="line"></span><br><span class="line">/bin/cp -R $CONFIGURATION_BUILD_DIR/InstaSoccer.app $CONFIGURATION_BUILD_DIR/Payload</span><br><span class="line"></span><br><span class="line">/bin/cp isoccer/icon/iTunesArtwork $CONFIGURATION_BUILD_DIR/iTunesArtwork</span><br><span class="line"></span><br><span class="line">cd $CONFIGURATION_BUILD_DIR</span><br><span class="line"></span><br><span class="line"># zip up the Instasoccer directory</span><br><span class="line"></span><br><span class="line">/usr/bin/zip -r InstaSoccer.ipa Payload iTunesArtwork</span><br><span class="line"></span><br><span class="line">/usr/bin/scp InstaSoccer.ipa sshuser@192.168.1.188:~/ipa_publish/ #scp到服务器路径，如果用Mac本机开启服务器，可以用cp到webserver路径</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>#第二步，部署服务器。<br>可以用Mac os的Web共享，也可以自己用python开一个，当然也可以用内网服务器、外网服务器，要求极低，扔几个静态文件就可以。<br>关于Mac os 10.8在偏好设置里面已经没有了Web共享，要开启的话需要手动写一下配置文件，方法请自搜。<br> <a href="http://www.minroad.com/wp-content/uploads/2013/06/%E5%BD%92%E6%A1%A32.zip" target="_blank" rel="noopener">点这里下载样例</a><br>样例中有2个文件，index.html和Info.plist<br>index.html修改一处，“<a href="http://192.168.1.188:8080/Info.plist”" target="_blank" rel="noopener">http://192.168.1.188:8080/Info.plist”</a> 改为你相应的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;Minroad一键安装&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;a style=&quot;font-size: 5em;&quot; href=&quot;itms-services://?action=download-manifest&amp;url=http://192.168.1.188:8080/Info.plist&quot;&gt;install&lt;/a&gt;</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure>
<p>Info.plist,修改ipa路径（如果你用scp的话请查看你scp后的路径是否与之相同），icon，版本号，bundle id，程序名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;items&lt;/key&gt;</span><br><span class="line">	&lt;array&gt;</span><br><span class="line">		&lt;dict&gt;</span><br><span class="line">			&lt;key&gt;assets&lt;/key&gt;</span><br><span class="line">			&lt;array&gt;</span><br><span class="line">				&lt;dict&gt;</span><br><span class="line">					&lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;software-package&lt;/string&gt;</span><br><span class="line">					&lt;key&gt;url&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;http://192.168.1.188:8080/InstaSoccer.ipa&lt;/string&gt;</span><br><span class="line">				&lt;/dict&gt;</span><br><span class="line">				&lt;dict&gt;</span><br><span class="line">					&lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;display-image&lt;/string&gt;</span><br><span class="line">					&lt;key&gt;needs-shine&lt;/key&gt;</span><br><span class="line">					&lt;true/&gt;</span><br><span class="line">					&lt;key&gt;url&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;http://192.168.1.188:8080/Icon.png&lt;/string&gt;</span><br><span class="line">				&lt;/dict&gt;</span><br><span class="line">				&lt;dict&gt;</span><br><span class="line">					&lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;full-size-image&lt;/string&gt;</span><br><span class="line">					&lt;key&gt;needs-shine&lt;/key&gt;</span><br><span class="line">					&lt;true/&gt;</span><br><span class="line">					&lt;key&gt;url&lt;/key&gt;</span><br><span class="line">					&lt;string&gt;http://192.168.1.188:8080/Icon.png&lt;/string&gt;</span><br><span class="line">				&lt;/dict&gt;</span><br><span class="line">			&lt;/array&gt;</span><br><span class="line">			&lt;key&gt;metadata&lt;/key&gt;</span><br><span class="line">			&lt;dict&gt;</span><br><span class="line">				&lt;key&gt;bundle-identifier&lt;/key&gt;</span><br><span class="line">				&lt;string&gt;com.minroad.appid&lt;/string&gt;</span><br><span class="line">				&lt;key&gt;bundle-version&lt;/key&gt;</span><br><span class="line">				&lt;string&gt;2.8.2&lt;/string&gt;</span><br><span class="line">				&lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">				&lt;string&gt;software&lt;/string&gt;</span><br><span class="line">				&lt;key&gt;subtitle&lt;/key&gt;</span><br><span class="line">				&lt;string&gt;一键安装副标题&lt;/string&gt;</span><br><span class="line">				&lt;key&gt;title&lt;/key&gt;</span><br><span class="line">				&lt;string&gt;一键安装程序名&lt;/string&gt;</span><br><span class="line">			&lt;/dict&gt;</span><br><span class="line">		&lt;/dict&gt;</span><br><span class="line">	&lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p>然后在启动webserver, 方法多了去了，提供一个python的，Mac os也可以用</p>
<p>cd 到当前目录<br>nohup python -m SimpleHTTPServer 8080 &gt; /dev/null 2&gt;&amp;1 &amp;</p>
<p>点击安装就自动安装了。省心省力！只要将网址收藏，以后分发的事与开发人员就无关咯</p>
<p>文本为转帖 出处在这里 ：<a href="http://www.minroad.com/?p=688" target="_blank" rel="noopener">http://www.minroad.com/?p=688</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="面试题集锦" class="lazyload">
                    <h1>面试题集锦</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年03月24日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 13 分钟</a>
        </div>

        <article>
            
                <p>OC内存管理遵循“谁创建，谁释放。谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向它发送alloc  new copy retain 消息，当释放该对象时需要发送release消息，当该对象引用计数为0时，系统将释放该对象，这是OC的手动内存管理机制；iOS5.0之后OC又提供了自动管理机制，ARC(automatic reference counting)，管理机制跟手动管理机制一样，只是不再需要调用 retain release autorelease；它是编译时特性，当你启用ARC时，在适当的位置插入release和autorelease；它引用了strong和weak 关键字，strong修饰的指针变量指向对象时，当指针指向新值,或者指针不再存在时,相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针则自动置为nil，这是ARC管理机制</p>
<p>线程和进程都是程序运行的基本单元,系统利用这些基本单元来实现系统对应用的并发性,<br>区别是他们是不同的操作系统的资源管理方式,进程有自己的地址空间,一个进程crash掉后,在保护模式下,不会对其他进程产生影响,而线程只是进程的不同的执行路径,它没有单独的地址空间,当一个线程Crash掉,整个进程就会crash掉,所以多进程的程序要比多线程的程序更健壮,但是进程之间的切换,耗资源比较大,所以执行效率要低一些,而当一些要求同时进行并且需要共享某些变量的并发操作时,只能使用多线程,不能使用多进程</p>
<p>block是一个块语句，是一种回调机制，能完成对象与对象之间的通信，基于c语言实现，因为block是在栈上执行的，所以我们需要copy一份到堆上进行手动管理，局部使用时，在MRC机制下，要使用<strong>block修饰，（全局变量等同于局部变量+</strong>block）,在ARC机制下，要使用__weak进行修饰。</p>
<p>static  有以下几条  修饰局部变量  只初始化一次  这个局部变量的作用域 只在这个方法哩  修饰全局变量  只在这个文件中使用    修饰方法  只能在这个文件内使用</p>
<p>#import   #include  @class</p>
<p>#import是oc导入头文件的关键字,#include是c/c++导入头文件的关键字,使用#import会自动导入一次,不会重复导入,相当于#include和#pragma once.@class是告诉编译器某个类的声明,当执行时才会去查看类的实现文件,使用@class可以解决头文件相互包含的问题</p>
<p>id 类型 是OC中得任意类型  因为OC的动态特性  只有在运行的时候才知道对象时是什么类型的<br>id 声明的对象有什么特性？<br>id类型是通用指针类型：因为通过指针，也就是内存地址来引用对象，所以可以自由地将它们在id变量之间来回赋值。因此返回id类型值的方法只是返回指向内存中某对象的指针。然后可以将该值赋给任何对象变量。因为无论在哪里，对象总是携带它的isa成员，所以即使将它存储在id类型的通用对象变量中，也总是可以确定它的类。</p>
<p>什么是TCP连接的三次握手<br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>视频播放:  最简单的是系统自带的MPMoviePlayerViewController</p>
<p>对象间是怎么通信的  :打点  代理delegate   block  KVO/KVC</p>
<p>OC优缺点:<br>优点:OC的动态特性 (动态类型   动态加载   动态绑定 )   支持OC和C/C++  混编<br>缺点:OC 不支持命名空间(加前缀来区别)  不支持多继承  可以通过类别来实现</p>
<p>类别的作用:<br>类的扩充  类的私有化  类的实现</p>
<p>get post 区别</p>
<ol>
<li>get是从服务器上获取数据，post是向服务器传送数据。</li>
<li>get是把参数数据队列加到URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li>
<li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form表单获取提交的数据。</li>
<li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li>
<li>get安全性非常低，post安全性较高</li>
</ol>
<p>UDP/TCP的区别</p>
<p>TCP—传输控制协议 ,提供的是面向连接可靠的字节流服务. 当客户端和服务器彼此交换数据前,必须在双方建立一个TCP连接 之后才能传输数据,TCP提供超时重发 丢弃重复数据 检验数据  流量控制等 保证数据从一端到另一端</p>
<p>UDP- 用户数据包协议 是一个简单的面向数据报的传输层协议 UDP不提供可靠连接 它仅仅是吧应用程序传给IP层的数据报发送出去 但是并不能保证他们能到达目的地,由于UDP 在传输数据前不再客户端和服务端建立一个可靠的连接  且没有超时重发机制 所以传输速度很快.</p>
<p>KVC/KVO<br>KVC  Key-values-coding  他是一种可以直接通过字符串的名字 即Key 来访问 属性的方式 而不是通过调用setter   getter 方法来访问支持类对象和内建基本数据类型 简化代码</p>
<p>KVO  它是一种观察者模式 Key-valus-observing  当指定的对象的属性被修改后,该对象就会接收到通知,简单的说就是每次指定的对象的属性被修改后 KVO就会自动的通知响应的观察者</p>
<p>如何理解MVC 模式<br>MVC是一种设计模式  Mmodel表示数据模型  View 表示视图 Controller 表示控制器<br>数据模型: 负责存储 定义 操作数据<br>视图: 用来展示数据给用户 和用户进行操作交互<br>控制器: 是M和V 协调者 控制器获取数据  将数据交给视图区展示</p>
<p>Iphone 和IPAD 有什么区别  有哪些组件不一样?<br>IPAD里面多了两个空间  弹出控制器(UIPopoverController) 分割试图控制器 (UISplitViewController)</p>
<p>readwrite   readonly assign retain copy monatomic  的作用</p>
<p>readwrite  是可读写特性 需要生成getter方法 和setter方法时调用<br>readonly   是只读特性 只会生成getter方法 不会生成setter方法 不希望属性在类外改变<br>assign 是赋值特性  setter 将传入的参数赋给实例变量 进设置变量时候用<br>retain 表示持有型 setter 将传入的参数先保留在赋值,传入参数的retainconut 会+1<br>copy 表示拷贝特性 setter 方法将传入的对象复制一份 需要完全一份新的变量时调用<br>nonotmic  非原子性操作 决定编译器生成生成setter getter 是否原子操作</p>
<p>堆和栈的区别:<br>堆 :  是低地址向高地址增长的    为指针或者对象申请内存 (alloc  手动申请)    大部分野指针和内存泄露&amp;内存碎片都是出在这里问题上  成员来管理<br>栈 :  高地址向低地址增长   系统管理 系统自动分配   执行效率比堆高效  方法都是在栈上面执行</p>
<p> HTTP 和socket<br>HTTP: 单向的(只能客户端向服务器发送   服务器不能主动向客户端发消息)<br>  一次连接(一次请求完成 连接就关闭)<br>数据量大(请求时发送的数据包括有请求行 请求头 请求数据 比较多)<br>频繁请求的时候  使用轮询资源消耗太大<br>这时候就需要套接字来实现了</p>
<p>套接字 socket :双向的 长连接 数据量自己任意组织  所以数据量较小<br>不是一套网络协议  是给程序员提供的一共网络接口</p>
<p>OOD:面向对象设计<br>OOP:面向对象编程</p>
<p>C++/C 与OC 怎么混编<br>1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，<br>但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj- c的代码，因为cpp只是cpp。<br>2) 在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题<br>3）在cpp中混用obj- c其实就是使用obj-c编写的模块是我们想要的。<br>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。<br>实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。<br>如果模块以函数实现，那么头文件要按 c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。<br>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，<br>而不能直接使用实现代码，实际上cpp混用的是 obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp.</p>
<p>Plist 小文件写入速度快   不支持大文件    不能存对象<br>指针题</p>
<p>写一个NSSstring 类的实现<br>+(id)initWithCString:(const char *)nullTerminatedCString endcoding:(NSStringEncoding)encoding{</p>
<pre><code>NSString *obj;
obj = [self allocWithZone:NSDefaultMallocZone()];
obj = [obj initWithCString:nullTerminatedCString encoding:encoding];

return obj;
</code></pre><p>}</p>
<p>一个描述为Copy//retain的属性的被赋值的set 方法<br>-(void)setObject:(MyObj*)test<br>{</p>
<pre><code>if (object! = test)
{
    [object release];
}
object = [test copy/retain];
</code></pre><p>}<br>自动释放池是什么,如何工作<br>当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</p>
<ol>
<li>ojc-c 是通过一种”referring counting”(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁.</li>
<li>NSAutoreleasePool 就是用来做引用计数的管理工作的,这个东西一般不用你管的.</li>
<li>autorelease和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一.</li>
</ol>
<p>Runloop<br>Runloop是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环,用来不停的调度工作以及处理输入事件。<br>使用runloop的目的是让你的线程在有工作的时候忙于工作,而没工作的时候处于休眠状态。<br>Runloop还可以在loop在循环中的同时响应其他输入源，比如界面控件的按钮，手势等</p>
<p>ViewController的生命周期</p>
<p>1.）loadView：根视图view为空时，且view被访问时调用<br>2.）viewDidLoad：在controller的view为nil时调⽤。此⽅法在编程实现view时 调用,view 控制器默认会注册memory warning notification,<br>3.）viewWillAppear，viewDidAppear，viewWillDisAppear，viewDidDisAppear</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2016/03/18/%E5%9C%A8Mac%E4%B8%8B%E9%80%9A%E8%BF%87HEXO%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="在Mac下通过HEXO在Github上搭建博客" class="lazyload">
                    <h1>在Mac下通过HEXO在Github上搭建博客</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2016年03月18日</a>
            <a><i class="nexmoefont icon-areachart"></i>1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <p>经过一番折腾，总算是把Hexo给弄好了。在这期间遇到了各种问题，网上有的教程也有点老了，这里就再写一篇。最新的教程可以去Hexo官网查看。</p>
<p>前期准备<br>安装Xcode<br>Hexo的编译可能依赖Xcode。这个直接从App Store上下载就好了，没什么难度。</p>
<p>安装node.js<br>Hexo是基于node.js的，所以要去官网上下载下来安装。版本可以选择稳定版(4.3.1)也可以选择最新版(5.7.0)。<br>需要注意的是，Hexo 3.1.1测试的最低版本为0.12，所以安装的版本不要太旧，之前看到网上装的0.8.4的版本，我也这么装，结果有一大堆的报错。</p>
<p>注册Github账户<br>在本地搭建好Hexo后可以将内容同步到github上，可以在网上浏览。<br>可以去Github官网上去注册，注册的过程我就不罗嗦了，具体的过程可以去这个页面上跳到Github的那部分去看。<br>其中配置SSH Keys的那部分，可以选择不配制，不配置的话以后每次提交的时候就需要手动输入账号密码，如果配置了的话就不需要了。</p>
<p>正式安装<br>因为安装包中有些内容在墙外，所以可以换淘宝源，或者用<br><code>npm install -g hexo-cli –no-optional</code></p>
<p>来安装<br>然后进入你要安装的目录，如</p>
<p><code>cd ~/Document/hexo</code></p>
<p>然后安装</p>
<p><code>hexo init</code><br>安装好之后不要忘记执行</p>
<p><code>npm install</code><br>至此，就已经安装完毕了。是不是很简单呢？</p>
<p>后期部署<br>添加文章</p>
<p><code>hexo new “postName”</code><br>其中postName是博客名。</p>
<p>生成静态页面</p>
<p><code>hexo generate</code><br>或者也可以执行缩写</p>
<p>hexo g</p>
<p>本地启动<br>执行好上面的命令之后就可以在本地启用服务来看效果了。执行下面的命令：</p>
<p><code>hexo sever</code><br>或缩写</p>
<p><code>hexo s</code><br>看到 INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop. 之后，就可以在浏览器中打开页面<a href="http://localhost:4000来看了。" target="_blank" rel="noopener">http://localhost:4000来看了。</a></p>
<p>上传至Github<br>安装git部署插件<br>在部署之前，首先我们要确认在你的Github帐号的Repository中有 用户名.github.io 的项目。<br>在确认之后，就可以执行命令</p>
<p><code>npm install hexo-deployer-git –save</code><br>来安装插件</p>
<p>配置 _config.yml 文件<br>在Hexo安装的目录，如 ~/Document/hexo 中找到 _config.yml 文件。打开。<br>翻到最后，找到 deploy 字样，改成如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/用户名/用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>需要注意的是：冒号后面有一个空格；使用github可以不用写branch那一行。<br>如果要使用多个 deployer，可改成如下样式：</p>
<p>deploy:</p>
<p>type: git<br>repo:<br>type: heroku<br>repo:<br>同步<br>输入命令</p>
<p>hexo deploy</p>
<p>或者缩写</p>
<p>hexo d</p>
<p>来执行。<br>以后每次执行就可以依次输入下面三行命令：</p>
<p>hexo clean<br>hexo generate<br>hexo deploy</p>
<p>或者其缩写。</p>
<p>Hexo基本常用的命令就四个，而且还可以使用组合命令。基本命令如下：</p>
<figure class="highlight plain"><figcaption><span>g </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s = hexo server  #启动本地预览</span><br><span class="line">hexo d = hexo deploy  #远程部署</span><br><span class="line">hexo n &quot;文章标题&quot; = hexo new &quot;文章标题&quot;  #新建一篇博文</span><br></pre></td></tr></table></figure>
<p>　　我通常是选用组合命令，操作更为效率。如果你使用搜狗输入法的话，可以自定义一个短语，比如我输入hs则出现hexo s -g命令。</p>
<figure class="highlight plain"><figcaption><span>s -g  #等同先输入hexo g，再输入hexo s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g  #等同先输入hexo g，再输入hexo d</span><br></pre></td></tr></table></figure>
<p>最后优化<br>插件<br>我使用了几个常见的插件：</p>
<p>从Wordpress迁移到Hexo</p>
<p>npm install hexo-migrator-wordpress –save</p>
<p>在 WordPress 仪表盘中导出数据(“工具(Tools)” → “发布(Export)” → “文章(WordPress)”)<br>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。</p>
<p>hexo migrate wordpress</p>
<p>站点地图</p>
<p>npm install hexo-generator-sitemap –save</p>
<p>生成的sitemap.xml可以给搜索引擎收录使用。<br>如果要生成百度的sitemap，使用以下命令：</p>
<p>npm install hexo-generator-baidu-sitemap –save</p>
<p>RSS订阅</p>
<p>npm install <a href="mailto:hexo-generator-feed@1.0.3" target="_blank" rel="noopener">hexo-generator-feed@1.0.3</a> –save</p>
<p>配置文件里经常看见的/atom.xml就是由这个插件生成的</p>

            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool">
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>
 

<script src="/js/app.js?v=1616568501317"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
